# Формат представления данных в S-выражениях

## Основные правила формата
- Данные представляются как вложенные списки (Lisp-подобные S-выражения).
- Корневой элемент — список, где первый элемент — имя узла (строка), за ним следуют атрибуты и дочерние узлы/листовое значение (скаляр).
- Дочерние узлы: Вложенные списки аналогичного формата.
- Узел может содержать скалярное значение, если он является листом (рассмотрено далее).
- Если узел содержит несколько одинаковых дочерних, они просто повторяются в списке.

---

## Синтаксис
Узел — это базовая единица формата. Каждый узел представлен как список в скобках ( ... ), где:
Первый элемент — имя узла (строка, не начинающаяся с : или скобки (возможно позже добавим другие ограничения)).
За именем следуют атрибуты (опционально), дочерние узлы (опционально) или листовое значение (опционально), в зависимости от типа узла.

### Типы узлов:
1. Контейнерный узел: Содержит атрибуты (ключ-значение пары) и/или дочерние узлы. Не содержит листа.
Синтаксис: (Name (:attribute 22) (child "Ivan")) или (Name (child "Ivan"))
2. Листовой узел (leaf): Не должен содержать дочерних узлов, только скалярное значение.
Синтаксис: (Name (:attribute 22) "Value") или (Name "Value")
"Value" — скалярное значение (см. ниже).
3. Пустой узел: Узел без атрибутов, детей или значения.
Синтаксис: (Name)
Интерпретируется как пустой контейнер.

### Отличие атрибутов от детей/значений:
- Атрибут: Начинается с : (как ключ в Clojure, например, (:key "value")). Это подсписок из двух элементов: ключ (символ с :) и значение (скаляр).
- Дочерний узел: Вложенный список, начинающийся с имени.
- Листовое значение: Скаляр (не список), следующий сразу после имени или аттрибута в листовом узле.

То есть: 
Если элемент после имени — подсписок начиная с :, это атрибут.
Если подсписок начиная со строки (имени), это ребенок.
Если не список, а скаляр — это листовое значение (только в листовом узле).

### Грамматика
- document   ::= node
- node       ::= "(" name node_body ")"
- node_body  ::= attribute* (value | child*)?
- attribute  ::= "(" ":"name scalar ")"
- child      ::= node
- value      ::= scalar
- scalar     ::= string | number | boolean | null

---

## Скалярное значение (Scalar)
### Допустимые типы:
- string
- number
- boolean
- null

---

## Ограничения

- Атрибуты не могут идти после дочерних узлов или листового значения (порядок: имя → атрибуты → (дети или значение)).
- Несколько одинаковых атрибутов с одним ключом не допускаются (последний перезапишет предыдущий при парсинге, но считается ошибкой).
- Узел не может содержать одновременно листовое значение и детей.
- Корневой элемент — всегда один узел (не список узлов).
- Пустые списки внутри узла не допускаются (() как ребенок — ошибка).

---

## Пример эквивалента JSON в S-выражении
- JSON: {"person": 
            {"name": "Igor", 
            "age": 22, 
            "children": ["Ivan", "Petr"]
            }
        }

- S-выражение: (person 
                    (:name "Igor") 
                    (:age 22) 
                    (child "Ivan") (child "Petr"))


